\documentclass{article}
%\usepackage[hmargin=1in,vmargin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{booktabs}
\usepackage[numbers]{natbib}
\usepackage{../../trfrac}
\usepackage{varwidth}
\usepackage{verbatim}

\title{Merwyn RFC: Alternatives}
\author{Peter Jin}

% NB: `\<` and `\>` are supposed to be tabbing commands.
%\newcommand{\<}{\langle}
%\renewcommand{\>}{\rangle}
\renewcommand{\=}{\triangleq}

\begin{document}
\maketitle

\begin{abstract}
This note describes a proposed implementation of \emph{alternatives},
via the \texttt{alt} syntax, to provide static, lexically scoped, monomorphic
multimethods in Merwyn.
\end{abstract}

\section{Example}

\begin{figure}[h]
\centering
\begin{varwidth}{\linewidth}
%\begin{center}
\begin{verbatim}
alt zero in
alt add' in
(* ... *)
let alt zero: Int = 0n in
let alt zero: Flp = 0.0f in
let alt add': [Int, Int] -> Int = \x, y -> x + y
 in
let alt add': [Flp, Flp] -> Flp = \x, y -> x + y
 in
(* ... *)
\end{verbatim}
%\end{center}
\end{varwidth}
\end{figure}

\section{Introduction}

In a typical ML-like implementation of $\lambda$-calculus with
\texttt{let}-binding,
variable identifiers (such as \texttt{x} or \texttt{foo})
can be uniquely rewritten based on their lexical binding order,
so that the rewritten identifiers correspond one-to-one with bound definitions.
One desirable language extension is some form of overloading or multimethods,
where
identifiers may be allowed to refer to one and only one of several differently
typed implementations that are simultaneously in scope.
When a second form of binding is added to enable a form of overloading or
multimethods,
then identifiers may potentially map to a set of definitions.
The use of such an identifier is a choice among the set of definitions,
which generally requires knowledge of types.
Thus, some identifiers may require type inference in order to resolve to a
particular implementation with a principal type.

In our proposed implementation, identifiers are not directly typed
via the \emph{type context} $\Gamma$.
Rather, only definitions, which correspond to a unique binding of an expression
to an identifier, are directly typed.
The indirection between identifiers and definitions is represented by a
\emph{binding context}, which we denote with $\text{B}$,
mirroring the more familiar type context.
In our proposed implementation, the typing context strictly maps only
definitions to types;
the binding context maps identifiers to either definitions or
a set of \emph{alternative} definitions.

\section{Static Semantics}

\subsection{Syntax}

Notation:
\begin{align*}
  \texttt{x} &\in \texttt{Id} & \text{(identifiers)} \\
  x &\in \texttt{Def} & \text{(definitions)} \\
  a &\in 2^{\texttt{Def}} & \text{(alternative definitions)} \\
  e &\in \texttt{Exp} & \text{(expressions)} \\
  \tau &\in \texttt{Ty} & \text{(types)} \\
  \Gamma &: \texttt{Def} \to \texttt{Ty} & \text{(type context)} \\
  \text{B} &: \texttt{Id} \to \texttt{Def} + 2^{\texttt{Def}} & \text{(binding context)}
\end{align*}
Expressions:
\begin{align*}
  e ::=
   ~& c & \text{(literal constant)} \\
  |~& x & \text{(definition)} \\
  |~& \lambda x .~e & \text{(function abstraction)} \\
  |~& e[e'] & \text{(function application)} \\
  |~& \texttt{let x = $e$ in $e'$} & \text{(let-binding)} \\
  |~& \texttt{alt x in $e$} & \text{(alt-declaration)} \\
  |~& \texttt{let alt x: $\tau$ = $e$ in $e'$} & \text{(alt-binding)}
\end{align*}
Types:
\begin{align*}
  \tau ::=
   ~& \alpha & \text{(type variable)} \\
  |~& \beta & \text{(primitive type)} \\
  |~& \tau \to \tau & \text{(function type)}
\end{align*}

\subsection{Static Semantics}

\subsubsection{Typing rules}

\begin{align*}
  \trfrac[~({\sc Lit})]{}{\Gamma ; \text{B} \vdash c : \beta}
\end{align*}
\begin{align*}
  \trfrac[~({\sc Abs})]{\Gamma , x : \tau ; \text{B} , \texttt{x} \= x \vdash e : \tau'}{\Gamma ; \text{B} \vdash \lambda x .~e : \tau \to \tau'}
\end{align*}
\begin{align*}
  \trfrac[~({\sc App})]{\Gamma ; \text{B} \vdash e : \tau' \to \tau , e' : \tau'}{\Gamma ; \text{B} \vdash e[e'] : \tau}
\end{align*}
\begin{align*}
  \trfrac[~({\sc Ident})]{}{\Gamma , x : \tau ; \text{B} , \texttt{x} \= x \vdash \texttt{x} : \tau}
\end{align*}
\begin{align*}
  \trfrac[~({\sc Ident-Alt})]{\Gamma ; \text{B} , \texttt{x} \= a \vdash \texttt{x} : \tau~\text{where}~x \in a \wedge \tau = \Gamma[x]}{\Gamma - (a \backslash x) ; \text{B} , \texttt{x} \= a \vdash \texttt{x} : \tau}
\end{align*}
\begin{align*}
  \trfrac[~({\sc Let})]{\Gamma ; \text{B} \vdash e : \tau \qquad \Gamma , x : \tau ; \text{B} , \texttt{x} \= x \vdash e' : \tau'~\text{where}~x~\text{fresh in}~\Gamma}{\Gamma ; \text{B} \vdash \texttt{let x = $e$ in $e'$} : \tau'}
\end{align*}
\begin{align*}
  \trfrac[~({\sc Alt})]{\Gamma ; \text{B} , \texttt{x} \= \emptyset \vdash e : \tau}{\Gamma ; \text{B} \vdash \texttt{alt x in $e$} : \tau}
\end{align*}
\begin{align*}
  \trfrac[~({\sc Let-Alt})]{\Gamma ; \text{B} , \texttt{x} \= a \backslash x \vdash e : \tau \qquad \begin{tralign}&\Gamma , x : \tau ; \text{B} , \texttt{x} \= a \vdash e' : \tau' \\ &\begin{tralign}\text{where}&~x \in a~\text{fresh in}~\Gamma \\ \wedge&~\forall x_a \in a \backslash x .~\tau \neq \Gamma[x_a]\end{tralign}\end{tralign}}{\Gamma ; \text{B} , \texttt{x} \= a \backslash x \vdash \texttt{let alt x: $\tau$ = $e$ in $e'$} : \tau'}
\end{align*}

\section{Limitations}

One of the obvious limitations of
our proposed implementation of alternatives in Merwyn is its restriction to
a monomorphic fragment of the language.
We have not defined how alternatives as proposed may be extended with,
e.g., parametric polymorphism or other approaches to generics.
However, there are substantial benefits to monomorphism-by-default
\cite{vytiniotis10}.
In numerical or mathematical programs which are likely to be written using
Merwyn,
monomorphism-by-default might make even more sense.
So, limiting ourselves to the monomorphic fragment of the language may be
an acceptable tradeoff, at least for the moment,
and particularly with respect to our design of alternatives.

A corollary to the monomorphic limitation of alternatives is that
lexical, monomorphic alternatives can hinder \emph{compositionality}.%
\footnote{Thanks to Jamie Brandon for pointing this out.}
The current design of alternatives does not have a satisfactory answer to
the question of compositionality, other than to say that an eventual design
for generics will need to address this.

\section{Related Work}

Some earlier approaches to overloading via type inference involve computing
least common generalizers or anti-unification
\cite{smith94,camarao99}.
This complication arises because the interaction between identifier overloading
and parametric polymorphism, specifically type schemes,
yields (quantified) constrained types.
Consequently, resolving the overloaded identifier necessitates resolvable
solutions to type constraints, which is nontrivial.
In our implementation,
anti-unification of monomorphic alternative types is essentially trivial.

Our design of alternatives involves first declaring the overloadable
identifier before defining alterntive definitions,
which bears perhaps a more than passing resemblance to type classes
\cite{wadler89}.
However we have not further explored the connection between the two.

%\section{References}
\bibliographystyle{unsrtnat}
\bibliography{alt}

\end{document}
